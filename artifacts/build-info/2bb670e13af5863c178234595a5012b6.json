{
  "id": "2bb670e13af5863c178234595a5012b6",
  "_format": "hh-sol-build-info-1",
  "solcVersion": "0.7.5",
  "solcLongVersion": "0.7.5+commit.eb77ed08",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/proxy/gnosis/GnosisSafe.sol": {
        "content": "/**\r\n *Submitted for verification at Etherscan.io on 2019-12-26\r\n*/\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n// TODO find actual license\r\npragma solidity 0.7.5;\r\n\r\n/// @title SelfAuthorized - authorizes current contract to perform actions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\nabstract contract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n// /// @title MasterCopy - Base for master copy contracts (should always be first super contract)\r\n// ///         This contract is tightly coupled to our proxy contract (see `proxies/Proxy.sol`)\r\n// /// @author Richard Meissner - <richard@gnosis.io>\r\n// contract MasterCopy is SelfAuthorized {\r\n\r\n//     event ChangedMasterCopy(address masterCopy);\r\n\r\n//     // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n//     // It should also always be ensured that the address is stored alone (uses a full word)\r\n//     address private masterCopy;\r\n\r\n//     /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n//     /// @param _masterCopy New contract address.\r\n//     function changeMasterCopy(address _masterCopy)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Master copy address cannot be null.\r\n//         require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n//         masterCopy = _masterCopy;\r\n//         emit ChangedMasterCopy(_masterCopy);\r\n//     }\r\n// }\r\n\r\n\r\n// /// @title Module - Base class for modules.\r\n// /// @author Stefan George - <stefan@gnosis.pm>\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract Module is MasterCopy {\r\n\r\n//     ModuleManager public manager;\r\n\r\n//     modifier authorized() override {\r\n//         require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n//         _;\r\n//     }\r\n\r\n//     function setManager()\r\n//         internal\r\n//     {\r\n//         // manager can only be 0 at initalization of contract.\r\n//         // Check ensures that setup function can only be called once.\r\n//         require(address(manager) == address(0), \"Manager has already been set\");\r\n//         manager = ModuleManager(msg.sender);\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n// /// @title Enum - Collection of enums\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract Enum {\r\n//     enum Operation {\r\n//         Call,\r\n//         DelegateCall\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n// /// @title Executor - A contract that can execute transactions\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract Executor {\r\n\r\n//     function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\r\n//         internal\r\n//         returns (bool success)\r\n//     {\r\n//         if (operation == Enum.Operation.Call)\r\n//             success = executeCall(to, value, data, txGas);\r\n//         else if (operation == Enum.Operation.DelegateCall)\r\n//             success = executeDelegateCall(to, data, txGas);\r\n//         else\r\n//             success = false;\r\n//     }\r\n\r\n//     function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\r\n//         internal\r\n//         returns (bool success)\r\n//     {\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n//         }\r\n//     }\r\n\r\n//     function executeDelegateCall(address to, bytes memory data, uint256 txGas)\r\n//         internal\r\n//         returns (bool success)\r\n//     {\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\n// /// @title SecuredTokenTransfer - Secure token transfer\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract SecuredTokenTransfer {\r\n\r\n//     /// @dev Transfers a token and returns if it was a success\r\n//     /// @param token Token that should be transferred\r\n//     /// @param receiver Receiver to whom the token should be transferred\r\n//     /// @param amount The amount of tokens that should be transferred\r\n//     function transferToken (\r\n//         address token,\r\n//         address receiver,\r\n//         uint256 amount\r\n//     )\r\n//         internal\r\n//         returns (bool transferred)\r\n//     {\r\n//         bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\r\n//             let ptr := mload(0x40)\r\n//             mstore(0x40, add(ptr, returndatasize()))\r\n//             returndatacopy(ptr, 0, returndatasize())\r\n//             switch returndatasize()\r\n//             case 0 { transferred := success }\r\n//             case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\r\n//             default { transferred := 0 }\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// /// @title Module Manager - A contract that manages modules that can execute transactions via this contract\r\n// /// @author Stefan George - <stefan@gnosis.pm>\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract ModuleManager is SelfAuthorized, Executor {\r\n\r\n//     event EnabledModule(Module module);\r\n//     event DisabledModule(Module module);\r\n//     event ExecutionFromModuleSuccess(address indexed module);\r\n//     event ExecutionFromModuleFailure(address indexed module);\r\n\r\n//     address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n//     mapping (address => address) internal modules;\r\n\r\n//     function setupModules(address to, bytes memory data)\r\n//         internal\r\n//     {\r\n//         require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\r\n//         modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n//         if (to != address(0))\r\n//             // Setup has to complete successfully or transaction fails.\r\n//             require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n//     }\r\n\r\n//     /// @dev Allows to add a module to the whitelist.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param module Module to be whitelisted.\r\n//     function enableModule(Module module)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Module address cannot be null or sentinel.\r\n//         require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n//         // Module cannot be added twice.\r\n//         require(modules[address(module)] == address(0), \"Module has already been added\");\r\n//         modules[address(module)] = modules[SENTINEL_MODULES];\r\n//         modules[SENTINEL_MODULES] = address(module);\r\n//         emit EnabledModule(module);\r\n//     }\r\n\r\n//     /// @dev Allows to remove a module from the whitelist.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n//     /// @param module Module to be removed.\r\n//     function disableModule(Module prevModule, Module module)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Validate module address and check that it corresponds to module index.\r\n//         require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n//         require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\r\n//         modules[address(prevModule)] = modules[address(module)];\r\n//         modules[address(module)] = address(0);\r\n//         emit DisabledModule(module);\r\n//     }\r\n\r\n//     /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n//     /// @param to Destination address of module transaction.\r\n//     /// @param value Ether value of module transaction.\r\n//     /// @param data Data payload of module transaction.\r\n//     /// @param operation Operation type of module transaction.\r\n//     function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n//         public\r\n//         returns (bool success)\r\n//     {\r\n//         // Only whitelisted modules are allowed.\r\n//         require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\r\n//         // Execute transaction without further confirmations.\r\n//         success = execute(to, value, data, operation, gasleft());\r\n//         if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n//         else emit ExecutionFromModuleFailure(msg.sender);\r\n//     }\r\n\r\n//     /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\r\n//     /// @param to Destination address of module transaction.\r\n//     /// @param value Ether value of module transaction.\r\n//     /// @param data Data payload of module transaction.\r\n//     /// @param operation Operation type of module transaction.\r\n//     function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\r\n//         public\r\n//         returns (bool success, bytes memory returnData)\r\n//     {\r\n//         success = execTransactionFromModule(to, value, data, operation);\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             // Load free memory location\r\n//             let ptr := mload(0x40)\r\n//             // We allocate memory for the return data by setting the free memory location to\r\n//             // current free memory location + data size + 32 bytes for data size value\r\n//             mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\r\n//             // Store the size\r\n//             mstore(ptr, returndatasize())\r\n//             // Store the data\r\n//             returndatacopy(add(ptr, 0x20), 0, returndatasize())\r\n//             // Point the return data to the correct memory location\r\n//             returnData := ptr\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Returns array of first 10 modules.\r\n//     /// @return Array of modules.\r\n//     function getModules()\r\n//         public\r\n//         view\r\n//         returns (address[] memory)\r\n//     {\r\n//         (address[] memory array,) = getModulesPaginated(SENTINEL_MODULES, 10);\r\n//         return array;\r\n//     }\r\n\r\n//     /// @dev Returns array of modules.\r\n//     /// @param start Start of the page.\r\n//     /// @param pageSize Maximum number of modules that should be returned.\r\n//     /// @return Array of modules.\r\n//     function getModulesPaginated(address start, uint256 pageSize)\r\n//         public\r\n//         view\r\n//         returns (address[] memory array, address next)\r\n//     {\r\n//         // Init array with max page size\r\n//         array = new address[](pageSize);\r\n\r\n//         // Populate return array\r\n//         uint256 moduleCount = 0;\r\n//         address currentModule = modules[start];\r\n//         while(currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\r\n//             array[moduleCount] = currentModule;\r\n//             currentModule = modules[currentModule];\r\n//             moduleCount++;\r\n//         }\r\n//         next = currentModule;\r\n//         // Set correct size of returned array\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             mstore(array, moduleCount)\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n// /// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\r\n// /// @author Stefan George - <stefan@gnosis.pm>\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract OwnerManager is SelfAuthorized {\r\n\r\n//     event AddedOwner(address owner);\r\n//     event RemovedOwner(address owner);\r\n//     event ChangedThreshold(uint256 threshold);\r\n\r\n//     address internal constant SENTINEL_OWNERS = address(0x1);\r\n\r\n//     mapping(address => address) internal owners;\r\n//     uint256 ownerCount;\r\n//     uint256 internal threshold;\r\n\r\n//     /// @dev Setup function sets initial storage of contract.\r\n//     /// @param _owners List of Safe owners.\r\n//     /// @param _threshold Number of required confirmations for a Safe transaction.\r\n//     function setupOwners(address[] memory _owners, uint256 _threshold)\r\n//         internal\r\n//     {\r\n//         // Threshold can only be 0 at initialization.\r\n//         // Check ensures that setup function can only be called once.\r\n//         require(threshold == 0, \"Owners have already been setup\");\r\n//         // Validate that threshold is smaller than number of added owners.\r\n//         require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n//         // There has to be at least one Safe owner.\r\n//         require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n//         // Initializing Safe owners.\r\n//         address currentOwner = SENTINEL_OWNERS;\r\n//         for (uint256 i = 0; i < _owners.length; i++) {\r\n//             // Owner address cannot be null.\r\n//             address owner = _owners[i];\r\n//             require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n//             // No duplicate owners allowed.\r\n//             require(owners[owner] == address(0), \"Duplicate owner address provided\");\r\n//             owners[currentOwner] = owner;\r\n//             currentOwner = owner;\r\n//         }\r\n//         owners[currentOwner] = SENTINEL_OWNERS;\r\n//         ownerCount = _owners.length;\r\n//         threshold = _threshold;\r\n//     }\r\n\r\n//     /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param owner New owner address.\r\n//     /// @param _threshold New threshold.\r\n//     function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Owner address cannot be null.\r\n//         require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n//         // No duplicate owners allowed.\r\n//         require(owners[owner] == address(0), \"Address is already an owner\");\r\n//         owners[owner] = owners[SENTINEL_OWNERS];\r\n//         owners[SENTINEL_OWNERS] = owner;\r\n//         ownerCount++;\r\n//         emit AddedOwner(owner);\r\n//         // Change threshold if threshold was changed.\r\n//         if (threshold != _threshold)\r\n//             changeThreshold(_threshold);\r\n//     }\r\n\r\n//     /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n//     /// @param owner Owner address to be removed.\r\n//     /// @param _threshold New threshold.\r\n//     function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Only allow to remove an owner, if threshold can still be reached.\r\n//         require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n//         // Validate owner address and check that it corresponds to owner index.\r\n//         require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n//         require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n//         owners[prevOwner] = owners[owner];\r\n//         owners[owner] = address(0);\r\n//         ownerCount--;\r\n//         emit RemovedOwner(owner);\r\n//         // Change threshold if threshold was changed.\r\n//         if (threshold != _threshold)\r\n//             changeThreshold(_threshold);\r\n//     }\r\n\r\n//     /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n//     /// @param oldOwner Owner address to be replaced.\r\n//     /// @param newOwner New owner address.\r\n//     function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Owner address cannot be null.\r\n//         require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n//         // No duplicate owners allowed.\r\n//         require(owners[newOwner] == address(0), \"Address is already an owner\");\r\n//         // Validate oldOwner address and check that it corresponds to owner index.\r\n//         require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n//         require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n//         owners[newOwner] = owners[oldOwner];\r\n//         owners[prevOwner] = newOwner;\r\n//         owners[oldOwner] = address(0);\r\n//         emit RemovedOwner(oldOwner);\r\n//         emit AddedOwner(newOwner);\r\n//     }\r\n\r\n//     /// @dev Allows to update the number of required confirmations by Safe owners.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param _threshold New threshold.\r\n//     function changeThreshold(uint256 _threshold)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         // Validate that threshold is smaller than number of owners.\r\n//         require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n//         // There has to be at least one Safe owner.\r\n//         require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n//         threshold = _threshold;\r\n//         emit ChangedThreshold(threshold);\r\n//     }\r\n\r\n//     function getThreshold()\r\n//         public\r\n//         view\r\n//         returns (uint256)\r\n//     {\r\n//         return threshold;\r\n//     }\r\n\r\n//     function isOwner(address owner)\r\n//         public\r\n//         view\r\n//         returns (bool)\r\n//     {\r\n//         return owner != SENTINEL_OWNERS && owners[owner] != address(0);\r\n//     }\r\n\r\n//     /// @dev Returns array of owners.\r\n//     /// @return Array of Safe owners.\r\n//     function getOwners()\r\n//         public\r\n//         view\r\n//         returns (address[] memory)\r\n//     {\r\n//         address[] memory array = new address[](ownerCount);\r\n\r\n//         // populate return array\r\n//         uint256 index = 0;\r\n//         address currentOwner = owners[SENTINEL_OWNERS];\r\n//         while(currentOwner != SENTINEL_OWNERS) {\r\n//             array[index] = currentOwner;\r\n//             currentOwner = owners[currentOwner];\r\n//             index ++;\r\n//         }\r\n//         return array;\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n// /// @title Fallback Manager - A contract that manages fallback calls made to this contract\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract FallbackManager is SelfAuthorized {\r\n\r\n//     // keccak256(\"fallback_manager.handler.address\")\r\n//     bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n//     function internalSetFallbackHandler(address handler) internal {\r\n//         bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             sstore(slot, handler)\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Allows to add a contract to handle fallback calls.\r\n//     ///      Only fallback calls without value and with data will be forwarded.\r\n//     ///      This can only be done via a Safe transaction.\r\n//     /// @param handler contract to handle fallbacks calls.\r\n//     function setFallbackHandler(address handler)\r\n//         public\r\n//         authorized\r\n//     {\r\n//         internalSetFallbackHandler(handler);\r\n//     }\r\n\r\n//     fallback()\r\n//         external\r\n//         payable\r\n//     {\r\n//         // Only calls without value and with data will be forwarded\r\n//         if (msg.value > 0 || msg.data.length == 0) {\r\n//             return;\r\n//         }\r\n//         bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\r\n//         address handler;\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             handler := sload(slot)\r\n//         }\r\n\r\n//         if (handler != address(0)) {\r\n//             // solium-disable-next-line security/no-inline-assembly\r\n//             assembly {\r\n//                 calldatacopy(0, 0, calldatasize())\r\n//                 let success := call(gas(), handler, 0, 0, calldatasize(), 0, 0)\r\n//                 returndatacopy(0, 0, returndatasize())\r\n//                 if eq(success, 0) { revert(0, returndatasize()) }\r\n//                 return(0, returndatasize())\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// /// @title SignatureDecoder - Decodes signatures that a encoded as bytes\r\n// /// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n// /// @author Richard Meissner - <richard@gnosis.pm>\r\n// contract SignatureDecoder {\r\n    \r\n//     /// @dev Recovers address who signed the message\r\n//     /// @param messageHash operation ethereum signed message hash\r\n//     /// @param messageSignature message `txHash` signature\r\n//     /// @param pos which signature to read\r\n//     function recoverKey (\r\n//         bytes32 messageHash,\r\n//         bytes memory messageSignature,\r\n//         uint256 pos\r\n//     )\r\n//         internal\r\n//         pure\r\n//         returns (address)\r\n//     {\r\n//         uint8 v;\r\n//         bytes32 r;\r\n//         bytes32 s;\r\n//         (v, r, s) = signatureSplit(messageSignature, pos);\r\n//         return ecrecover(messageHash, v, r, s);\r\n//     }\r\n\r\n//     /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\r\n//     /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\r\n//     /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\r\n//     /// @param signatures concatenated rsv signatures\r\n//     function signatureSplit(bytes memory signatures, uint256 pos)\r\n//         internal\r\n//         pure\r\n//         returns (uint8 v, bytes32 r, bytes32 s)\r\n//     {\r\n//         // The signature format is a compact form of:\r\n//         //   {bytes32 r}{bytes32 s}{uint8 v}\r\n//         // Compact means, uint8 is not padded to 32 bytes.\r\n//         // solium-disable-next-line security/no-inline-assembly\r\n//         assembly {\r\n//             let signaturePos := mul(0x41, pos)\r\n//             r := mload(add(signatures, add(signaturePos, 0x20)))\r\n//             s := mload(add(signatures, add(signaturePos, 0x40)))\r\n//             // Here we are loading the last 32 bytes, including 31 bytes\r\n//             // of 's'. There is no 'mload8' to do this.\r\n//             //\r\n//             // 'byte' is not working due to the Solidity parser, so lets\r\n//             // use the second best option, 'and'\r\n//             v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n\r\n\r\n// abstract contract ISignatureValidatorConstants {\r\n//     // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n//     bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\r\n// }\r\n\r\n// abstract contract ISignatureValidator is ISignatureValidatorConstants {\r\n\r\n//     /**\r\n//     * @dev Should return whether the signature provided is valid for the provided data\r\n//     * @param _data Arbitrary length data signed on the behalf of address(this)\r\n//     * @param _signature Signature byte array associated with _data\r\n//     *\r\n//     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n//     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n//     * MUST allow external calls\r\n//     */\r\n//     function isValidSignature(\r\n//         bytes memory _data,\r\n//         bytes memory _signature)\r\n//         public\r\n//         view\r\n//         virtual\r\n//         returns (bytes4);\r\n// }\r\n\r\n\r\n// /**\r\n//  * @title SafeMath\r\n//  * @dev Math operations with safety checks that revert on error\r\n//  * TODO: remove once open zeppelin update to solc 0.5.0\r\n//  */\r\n// library SafeMath {\r\n\r\n//   /**\r\n//   * @dev Multiplies two numbers, reverts on overflow.\r\n//   */\r\n//   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n//     // benefit is lost if 'b' is also tested.\r\n//     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n//     if (a == 0) {\r\n//       return 0;\r\n//     }\r\n\r\n//     uint256 c = a * b;\r\n//     require(c / a == b);\r\n\r\n//     return c;\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n//   */\r\n//   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n//     uint256 c = a / b;\r\n//     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n//     return c;\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n//   */\r\n//   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     require(b <= a);\r\n//     uint256 c = a - b;\r\n\r\n//     return c;\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Adds two numbers, reverts on overflow.\r\n//   */\r\n//   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     uint256 c = a + b;\r\n//     require(c >= a);\r\n\r\n//     return c;\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n//   * reverts when dividing by zero.\r\n//   */\r\n//   function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     require(b != 0);\r\n//     return a % b;\r\n//   }\r\n// }\r\n\r\n// /// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\r\n// /// @author Stefan George - <stefan@gnosis.io>\r\n// /// @author Richard Meissner - <richard@gnosis.io>\r\n// /// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\r\n// contract GnosisSafe\r\n//     is MasterCopy, ModuleManager, OwnerManager, SignatureDecoder, SecuredTokenTransfer, ISignatureValidatorConstants, FallbackManager {\r\n\r\n//     using SafeMath for uint256;\r\n\r\n//     string public constant NAME = \"Gnosis Safe\";\r\n//     string public constant VERSION = \"1.1.1\";\r\n\r\n//     //keccak256(\r\n//     //    \"EIP712Domain(address verifyingContract)\"\r\n//     //);\r\n//     bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\r\n\r\n//     //keccak256(\r\n//     //    \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\r\n//     //);\r\n//     bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\r\n\r\n//     //keccak256(\r\n//     //    \"SafeMessage(bytes message)\"\r\n//     //);\r\n//     bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\r\n\r\n//     event ApproveHash(\r\n//         bytes32 indexed approvedHash,\r\n//         address indexed owner\r\n//     );\r\n//     event SignMsg(\r\n//         bytes32 indexed msgHash\r\n//     );\r\n//     event ExecutionFailure(\r\n//         bytes32 txHash, uint256 payment\r\n//     );\r\n//     event ExecutionSuccess(\r\n//         bytes32 txHash, uint256 payment\r\n//     );\r\n\r\n//     uint256 public nonce;\r\n//     bytes32 public domainSeparator;\r\n//     // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\r\n//     mapping(bytes32 => uint256) public signedMessages;\r\n//     // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\r\n//     mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\r\n\r\n//     // This constructor ensures that this contract can only be used as a master copy for Proxy contracts\r\n//     constructor() {\r\n//         // By setting the threshold it is not possible to call setup anymore,\r\n//         // so we create a Safe with 0 owners and threshold 1.\r\n//         // This is an unusable Safe, perfect for the mastercopy\r\n//         threshold = 1;\r\n//     }\r\n\r\n//     /// @dev Setup function sets initial storage of contract.\r\n//     /// @param _owners List of Safe owners.\r\n//     /// @param _threshold Number of required confirmations for a Safe transaction.\r\n//     /// @param to Contract address for optional delegate call.\r\n//     /// @param data Data payload for optional delegate call.\r\n//     /// @param fallbackHandler Handler for fallback calls to this contract\r\n//     /// @param paymentToken Token that should be used for the payment (0 is ETH)\r\n//     /// @param payment Value that should be paid\r\n//     /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\r\n//     function setup(\r\n//         address[] calldata _owners,\r\n//         uint256 _threshold,\r\n//         address to,\r\n//         bytes calldata data,\r\n//         address fallbackHandler,\r\n//         address paymentToken,\r\n//         uint256 payment,\r\n//         address payable paymentReceiver\r\n//     )\r\n//         external\r\n//     {\r\n//         require(domainSeparator == 0, \"Domain Separator already set!\");\r\n//         domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\r\n//         setupOwners(_owners, _threshold);\r\n//         if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\r\n//         // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\r\n//         setupModules(to, data);\r\n\r\n//         if (payment > 0) {\r\n//             // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\r\n//             // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\r\n//             handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\r\n//     ///      Note: The fees are always transfered, even if the user transaction fails.\r\n//     /// @param to Destination address of Safe transaction.\r\n//     /// @param value Ether value of Safe transaction.\r\n//     /// @param data Data payload of Safe transaction.\r\n//     /// @param operation Operation type of Safe transaction.\r\n//     /// @param safeTxGas Gas that should be used for the Safe transaction.\r\n//     /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n//     /// @param gasPrice Gas price that should be used for the payment calculation.\r\n//     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n//     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n//     /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\r\n//     function execTransaction(\r\n//         address to,\r\n//         uint256 value,\r\n//         bytes calldata data,\r\n//         Enum.Operation operation,\r\n//         uint256 safeTxGas,\r\n//         uint256 baseGas,\r\n//         uint256 gasPrice,\r\n//         address gasToken,\r\n//         address payable refundReceiver,\r\n//         bytes calldata signatures\r\n//     )\r\n//         external\r\n//         returns (bool success)\r\n//     {\r\n//         bytes32 txHash;\r\n//         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n//         {\r\n//             bytes memory txHashData = encodeTransactionData(\r\n//                 to, value, data, operation, // Transaction info\r\n//                 safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\r\n//                 nonce\r\n//             );\r\n//             // Increase nonce and execute transaction.\r\n//             nonce++;\r\n//             txHash = keccak256(txHashData);\r\n//             checkSignatures(txHash, txHashData, signatures, true);\r\n//         }\r\n//         require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\r\n//         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\r\n//         {\r\n//             uint256 gasUsed = gasleft();\r\n//             // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\r\n//             success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\r\n//             gasUsed = gasUsed.sub(gasleft());\r\n//             // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\r\n//             uint256 payment = 0;\r\n//             if (gasPrice > 0) {\r\n//                 payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\r\n//             }\r\n//             if (success) emit ExecutionSuccess(txHash, payment);\r\n//             else emit ExecutionFailure(txHash, payment);\r\n//         }\r\n//     }\r\n\r\n//     function handlePayment(\r\n//         uint256 gasUsed,\r\n//         uint256 baseGas,\r\n//         uint256 gasPrice,\r\n//         address gasToken,\r\n//         address payable refundReceiver\r\n//     )\r\n//         private\r\n//         returns (uint256 payment)\r\n//     {\r\n//         // solium-disable-next-line security/no-tx-origin\r\n//         address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\r\n//         if (gasToken == address(0)) {\r\n//             // For ETH we will only adjust the gas price to not be higher than the actual used gas price\r\n//             payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\r\n//             // solium-disable-next-line security/no-send\r\n//             require(receiver.send(payment), \"Could not pay gas costs with ether\");\r\n//         } else {\r\n//             payment = gasUsed.add(baseGas).mul(gasPrice);\r\n//             require(transferToken(gasToken, receiver, payment), \"Could not pay gas costs with token\");\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\r\n//     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n//     * @param data That should be signed (this is passed to an external validator contract)\r\n//     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\r\n//     * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\r\n//     */\r\n//     function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\r\n//         internal\r\n//     {\r\n//         // Load threshold to avoid multiple storage loads\r\n//         uint256 _threshold = threshold;\r\n//         // Check that a threshold is set\r\n//         require(_threshold > 0, \"Threshold needs to be defined!\");\r\n//         // Check that the provided signature data is not too short\r\n//         require(signatures.length >= _threshold.mul(65), \"Signatures data too short\");\r\n//         // There cannot be an owner with address 0.\r\n//         address lastOwner = address(0);\r\n//         address currentOwner;\r\n//         uint8 v;\r\n//         bytes32 r;\r\n//         bytes32 s;\r\n//         uint256 i;\r\n//         for (i = 0; i < _threshold; i++) {\r\n//             (v, r, s) = signatureSplit(signatures, i);\r\n//             // If v is 0 then it is a contract signature\r\n//             if (v == 0) {\r\n//                 // When handling contract signatures the address of the contract is encoded into r\r\n//                 currentOwner = address(uint256(r));\r\n\r\n//                 // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\r\n//                 // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\r\n//                 // Here we only check that the pointer is not pointing inside the part that is being processed\r\n//                 require(uint256(s) >= _threshold.mul(65), \"Invalid contract signature location: inside static part\");\r\n\r\n//                 // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\r\n//                 require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\r\n\r\n//                 // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\r\n//                 uint256 contractSignatureLen;\r\n//                 // solium-disable-next-line security/no-inline-assembly\r\n//                 assembly {\r\n//                     contractSignatureLen := mload(add(add(signatures, s), 0x20))\r\n//                 }\r\n//                 require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\r\n\r\n//                 // Check signature\r\n//                 bytes memory contractSignature;\r\n//                 // solium-disable-next-line security/no-inline-assembly\r\n//                 assembly {\r\n//                     // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\r\n//                     contractSignature := add(add(signatures, s), 0x20)\r\n//                 }\r\n//                 require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\r\n//             // If v is 1 then it is an approved hash\r\n//             } else if (v == 1) {\r\n//                 // When handling approved hashes the address of the approver is encoded into r\r\n//                 currentOwner = address(uint256(r));\r\n//                 // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\r\n//                 require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\r\n//                 // Hash has been marked for consumption. If this hash was pre-approved free storage\r\n//                 if (consumeHash && msg.sender != currentOwner) {\r\n//                     approvedHashes[currentOwner][dataHash] = 0;\r\n//                 }\r\n//             } else if (v > 30) {\r\n//                 // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\r\n//                 currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\r\n//             } else {\r\n//                 // Use ecrecover with the messageHash for EOA signatures\r\n//                 currentOwner = ecrecover(dataHash, v, r, s);\r\n//             }\r\n//             require (\r\n//                 currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\r\n//                 \"Invalid owner provided\"\r\n//             );\r\n//             lastOwner = currentOwner;\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Allows to estimate a Safe transaction.\r\n//     ///      This method is only meant for estimation purpose, therefore two different protection mechanism against execution in a transaction have been made:\r\n//     ///      1.) The method can only be called from the safe itself\r\n//     ///      2.) The response is returned with a revert\r\n//     ///      When estimating set `from` to the address of the safe.\r\n//     ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\r\n//     /// @param to Destination address of Safe transaction.\r\n//     /// @param value Ether value of Safe transaction.\r\n//     /// @param data Data payload of Safe transaction.\r\n//     /// @param operation Operation type of Safe transaction.\r\n//     /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\r\n//     function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\r\n//         external\r\n//         authorized\r\n//         returns (uint256)\r\n//     {\r\n//         uint256 startGas = gasleft();\r\n//         // We don't provide an error message here, as we use it to return the estimate\r\n//         // solium-disable-next-line error-reason\r\n//         require(execute(to, value, data, operation, gasleft()));\r\n//         uint256 requiredGas = startGas - gasleft();\r\n//         // Convert response to string and return via error message\r\n//         revert(string(abi.encodePacked(requiredGas)));\r\n//     }\r\n\r\n//     /**\r\n//     * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\r\n//     * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\r\n//     */\r\n//     function approveHash(bytes32 hashToApprove)\r\n//         external\r\n//     {\r\n//         require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\r\n//         approvedHashes[msg.sender][hashToApprove] = 1;\r\n//         emit ApproveHash(hashToApprove, msg.sender);\r\n//     }\r\n\r\n//     /**\r\n//     * @dev Marks a message as signed\r\n//     * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\r\n//     */\r\n//     function signMessage(bytes calldata _data)\r\n//         external\r\n//         authorized\r\n//     {\r\n//         bytes32 msgHash = getMessageHash(_data);\r\n//         signedMessages[msgHash] = 1;\r\n//         emit SignMsg(msgHash);\r\n//     }\r\n\r\n//     /**\r\n//     * Implementation of ISignatureValidator (see `interfaces/ISignatureValidator.sol`)\r\n//     * @dev Should return whether the signature provided is valid for the provided data.\r\n//     *       The save does not implement the interface since `checkSignatures` is not a view method.\r\n//     *       The method will not perform any state changes (see parameters of `checkSignatures`)\r\n//     * @param _data Arbitrary length data signed on the behalf of address(this)\r\n//     * @param _signature Signature byte array associated with _data\r\n//     * @return a bool upon valid or invalid signature with corresponding _data\r\n//     */\r\n//     function isValidSignature(bytes calldata _data, bytes calldata _signature)\r\n//         external\r\n//         returns (bytes4)\r\n//     {\r\n//         bytes32 messageHash = getMessageHash(_data);\r\n//         if (_signature.length == 0) {\r\n//             require(signedMessages[messageHash] != 0, \"Hash not approved\");\r\n//         } else {\r\n//             // consumeHash needs to be false, as the state should not be changed\r\n//             checkSignatures(messageHash, _data, _signature, false);\r\n//         }\r\n//         return EIP1271_MAGIC_VALUE;\r\n//     }\r\n\r\n//     /// @dev Returns hash of a message that can be signed by owners.\r\n//     /// @param message Message that should be hashed\r\n//     /// @return Message hash.\r\n//     function getMessageHash(\r\n//         bytes memory message\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (bytes32)\r\n//     {\r\n//         bytes32 safeMessageHash = keccak256(\r\n//             abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\r\n//         );\r\n//         return keccak256(\r\n//             abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\r\n//         );\r\n//     }\r\n\r\n//     /// @dev Returns the bytes that are hashed to be signed by owners.\r\n//     /// @param to Destination address.\r\n//     /// @param value Ether value.\r\n//     /// @param data Data payload.\r\n//     /// @param operation Operation type.\r\n//     /// @param safeTxGas Fas that should be used for the safe transaction.\r\n//     /// @param baseGas Gas costs for data used to trigger the safe transaction.\r\n//     /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n//     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n//     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n//     /// @param _nonce Transaction nonce.\r\n//     /// @return Transaction hash bytes.\r\n//     function encodeTransactionData(\r\n//         address to,\r\n//         uint256 value,\r\n//         bytes memory data,\r\n//         Enum.Operation operation,\r\n//         uint256 safeTxGas,\r\n//         uint256 baseGas,\r\n//         uint256 gasPrice,\r\n//         address gasToken,\r\n//         address refundReceiver,\r\n//         uint256 _nonce\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (bytes memory)\r\n//     {\r\n//         bytes32 safeTxHash = keccak256(\r\n//             abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\r\n//         );\r\n//         return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\r\n//     }\r\n\r\n//     /// @dev Returns hash to be signed by owners.\r\n//     /// @param to Destination address.\r\n//     /// @param value Ether value.\r\n//     /// @param data Data payload.\r\n//     /// @param operation Operation type.\r\n//     /// @param safeTxGas Fas that should be used for the safe transaction.\r\n//     /// @param baseGas Gas costs for data used to trigger the safe transaction.\r\n//     /// @param gasPrice Maximum gas price that should be used for this transaction.\r\n//     /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n//     /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n//     /// @param _nonce Transaction nonce.\r\n//     /// @return Transaction hash.\r\n//     function getTransactionHash(\r\n//         address to,\r\n//         uint256 value,\r\n//         bytes memory data,\r\n//         Enum.Operation operation,\r\n//         uint256 safeTxGas,\r\n//         uint256 baseGas,\r\n//         uint256 gasPrice,\r\n//         address gasToken,\r\n//         address refundReceiver,\r\n//         uint256 _nonce\r\n//     )\r\n//         public\r\n//         view\r\n//         returns (bytes32)\r\n//     {\r\n//         return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\r\n//     }\r\n// }"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  },
  "output": {
    "contracts": {
      "contracts/dependencies/holyzeppelin/contracts/proxy/gnosis/GnosisSafe.sol": {
        "SelfAuthorized": {
          "abi": [],
          "evm": {
            "bytecode": {
              "generatedSources": [],
              "linkReferences": {},
              "object": "",
              "opcodes": "",
              "sourceMap": ""
            },
            "deployedBytecode": {
              "generatedSources": [],
              "immutableReferences": {},
              "linkReferences": {},
              "object": "",
              "opcodes": "",
              "sourceMap": ""
            },
            "methodIdentifiers": {}
          }
        }
      }
    },
    "sources": {
      "contracts/dependencies/holyzeppelin/contracts/proxy/gnosis/GnosisSafe.sol": {
        "ast": {
          "absolutePath": "contracts/dependencies/holyzeppelin/contracts/proxy/gnosis/GnosisSafe.sol",
          "exportedSymbols": {
            "SelfAuthorized": [
              18
            ]
          },
          "id": 19,
          "license": "AGPL-3.0-or-later",
          "nodeType": "SourceUnit",
          "nodes": [
            {
              "id": 1,
              "literals": [
                "solidity",
                "0.7",
                ".5"
              ],
              "nodeType": "PragmaDirective",
              "src": "145:22:0"
            },
            {
              "abstract": true,
              "baseContracts": [],
              "contractDependencies": [],
              "contractKind": "contract",
              "documentation": {
                "id": 2,
                "nodeType": "StructuredDocumentation",
                "src": "171:128:0",
                "text": "@title SelfAuthorized - authorizes current contract to perform actions\n @author Richard Meissner - <richard@gnosis.pm>"
              },
              "fullyImplemented": true,
              "id": 18,
              "linearizedBaseContracts": [
                18
              ],
              "name": "SelfAuthorized",
              "nodeType": "ContractDefinition",
              "nodes": [
                {
                  "body": {
                    "id": 16,
                    "nodeType": "Block",
                    "src": "361:115:0",
                    "statements": [
                      {
                        "expression": {
                          "arguments": [
                            {
                              "commonType": {
                                "typeIdentifier": "t_address",
                                "typeString": "address"
                              },
                              "id": 11,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "leftExpression": {
                                "expression": {
                                  "id": 5,
                                  "name": "msg",
                                  "nodeType": "Identifier",
                                  "overloadedDeclarations": [],
                                  "referencedDeclaration": -15,
                                  "src": "380:3:0",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_magic_message",
                                    "typeString": "msg"
                                  }
                                },
                                "id": 6,
                                "isConstant": false,
                                "isLValue": false,
                                "isPure": false,
                                "lValueRequested": false,
                                "memberName": "sender",
                                "nodeType": "MemberAccess",
                                "src": "380:10:0",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_address_payable",
                                  "typeString": "address payable"
                                }
                              },
                              "nodeType": "BinaryOperation",
                              "operator": "==",
                              "rightExpression": {
                                "arguments": [
                                  {
                                    "id": 9,
                                    "name": "this",
                                    "nodeType": "Identifier",
                                    "overloadedDeclarations": [],
                                    "referencedDeclaration": -28,
                                    "src": "402:4:0",
                                    "typeDescriptions": {
                                      "typeIdentifier": "t_contract$_SelfAuthorized_$18",
                                      "typeString": "contract SelfAuthorized"
                                    }
                                  }
                                ],
                                "expression": {
                                  "argumentTypes": [
                                    {
                                      "typeIdentifier": "t_contract$_SelfAuthorized_$18",
                                      "typeString": "contract SelfAuthorized"
                                    }
                                  ],
                                  "id": 8,
                                  "isConstant": false,
                                  "isLValue": false,
                                  "isPure": true,
                                  "lValueRequested": false,
                                  "nodeType": "ElementaryTypeNameExpression",
                                  "src": "394:7:0",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_type$_t_address_$",
                                    "typeString": "type(address)"
                                  },
                                  "typeName": {
                                    "id": 7,
                                    "name": "address",
                                    "nodeType": "ElementaryTypeName",
                                    "src": "394:7:0",
                                    "typeDescriptions": {}
                                  }
                                },
                                "id": 10,
                                "isConstant": false,
                                "isLValue": false,
                                "isPure": false,
                                "kind": "typeConversion",
                                "lValueRequested": false,
                                "names": [],
                                "nodeType": "FunctionCall",
                                "src": "394:13:0",
                                "tryCall": false,
                                "typeDescriptions": {
                                  "typeIdentifier": "t_address",
                                  "typeString": "address"
                                }
                              },
                              "src": "380:27:0",
                              "typeDescriptions": {
                                "typeIdentifier": "t_bool",
                                "typeString": "bool"
                              }
                            },
                            {
                              "hexValue": "4d6574686f642063616e206f6e6c792062652063616c6c65642066726f6d207468697320636f6e7472616374",
                              "id": 12,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": true,
                              "kind": "string",
                              "lValueRequested": false,
                              "nodeType": "Literal",
                              "src": "409:46:0",
                              "typeDescriptions": {
                                "typeIdentifier": "t_stringliteral_c4780ef0a1d41d59bac8c510cf9ada421bccf2b90f75a8e4ba2e8c09e8d72733",
                                "typeString": "literal_string \"Method can only be called from this contract\""
                              },
                              "value": "Method can only be called from this contract"
                            }
                          ],
                          "expression": {
                            "argumentTypes": [
                              {
                                "typeIdentifier": "t_bool",
                                "typeString": "bool"
                              },
                              {
                                "typeIdentifier": "t_stringliteral_c4780ef0a1d41d59bac8c510cf9ada421bccf2b90f75a8e4ba2e8c09e8d72733",
                                "typeString": "literal_string \"Method can only be called from this contract\""
                              }
                            ],
                            "id": 4,
                            "name": "require",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [
                              -18,
                              -18
                            ],
                            "referencedDeclaration": -18,
                            "src": "372:7:0",
                            "typeDescriptions": {
                              "typeIdentifier": "t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$",
                              "typeString": "function (bool,string memory) pure"
                            }
                          },
                          "id": 13,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "kind": "functionCall",
                          "lValueRequested": false,
                          "names": [],
                          "nodeType": "FunctionCall",
                          "src": "372:84:0",
                          "tryCall": false,
                          "typeDescriptions": {
                            "typeIdentifier": "t_tuple$__$",
                            "typeString": "tuple()"
                          }
                        },
                        "id": 14,
                        "nodeType": "ExpressionStatement",
                        "src": "372:84:0"
                      },
                      {
                        "id": 15,
                        "nodeType": "PlaceholderStatement",
                        "src": "467:1:0"
                      }
                    ]
                  },
                  "id": 17,
                  "name": "authorized",
                  "nodeType": "ModifierDefinition",
                  "parameters": {
                    "id": 3,
                    "nodeType": "ParameterList",
                    "parameters": [],
                    "src": "358:2:0"
                  },
                  "src": "339:137:0",
                  "virtual": false,
                  "visibility": "internal"
                }
              ],
              "scope": 19,
              "src": "299:180:0"
            }
          ],
          "src": "145:47304:0"
        },
        "id": 0
      }
    }
  }
}
